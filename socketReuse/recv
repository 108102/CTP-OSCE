recv function:
https://docs.microsoft.com/en-us/windows/win32/api/winsock/nf-winsock-recv

int flags --> integerer for flags
int len   --> length of the payload we're sending
char *buf --> Pointer to the payload for this recv function.
SOCKET s, --> Socket file descriptor

We will need all of these in order to reuse/make a 2nd call to ws2_32.recv.
----------------
----------------

We want to reuse the socket file descriptor for vulnserver.

1) Restart vulnserver, you'll be at the program entry point, and just scroll to see calls to ws32.
        - This could be any of them, accept, send, receive, etc.

2) Note the address down.
      Example: 0040252C

Now see from the MSDN, on vulnserver, we want to see what these variables look like during a normal operation
  Of this binary

3) Set a breakpoint at recv, and then telnet into it.
 
We hit our breakpoint, and if we look at the stack we see what the recv syntax is!
    - Socket - 84             --> Socket file descriptor of 84.
    - Buffer = 003E4A80       --> Buffer destination pointer
    - BufSize = 1000 (4096.)  --> Buffer length of 4,096 bytes.
    - Flags = 0
    
4) Note all of this down.

We need push these arguments to the call in reverse order, then push them onto the stack, then make the call to recv.

5) Task 1, push 0 onto the stack (Flags)
    XOR EAX, EAX
    PUSH EAX
    
6) Task 2, Push the length of our input: (1000, this is enough space for our reverse shell)
    PUSH EAX, EAX
    ADD AH, 10 
    
 7) Task 3, Push the 



Socket descriptor might not be the same every time the program runs, this could change, and could be affected by ASLR.
So we want a dynamic way to figure out what we want this socket descriptor is.
 
